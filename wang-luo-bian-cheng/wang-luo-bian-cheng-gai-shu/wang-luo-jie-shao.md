# 网络通信概述
## 1.什么是网络
说明：网络是一种辅助双方或多方连接在一起的工具
## 2.使用网络的目的
为了联通多方进行通信，即把数据从一方传到另一方。
我们之前学习的程序都是单机的，既不能和其他电脑上的程序通信，所以为了能和其他的电脑之间传递数据，需要使用网络。

# TCP/IP简介
## 1.什么是协议
为了使数据在网络上从源到达目的，网络通信的参与方必须遵循相同的规则，这套规则称为协议。
## 2.TCP/IP协议（族）
为了把全世界的计算机连接到一起,规定了一套全球通用的协议，也就是互联网协议族。
因为互联网协议包含了上百种协议，但其中最重要的两个是TCP和IP协议，所以互联网协议一般简称为TCP/IP协议。

# 端口
## 1.什么是端口
如果把一个进程比喻为一个房子，那端口就是这个房间的大门，是出入房间的必经之路。
![](/assets/端口.png)

如果一个进程要收发数据,那么就需要有这样的端口.
在linux系统当中，端口可以有65536(2的16次方)个之多。操作系统为了统一管理，所以进行了编号,这就是端口号。
## 2.知名端口号
知名端口就是众所周知的端口号范围从0到1023
比如:80端口 HTTP服务，22 SSH 21 FTP

## 3.动态端口
动态端口的范围从1024到65535
之所以叫动态端口,是因为他一般不固定分配某种服务,而是动态分配的。
动态分配是指当一个系统进程或应用程序经常需要网络通信时，向主机申请一个端口，主机从可用端口号中分配一个供他使用。

# IP地址
## 1.ip地址的作用
用来在网络中标记一台电脑的数字，比如192.168.1.1，在本地局域网上是唯一的。
# TCP和UDP协议
## 1.什么是TCP协议
TCP（Transmission Control Protocol，传输控制协议）是面向连接的协议，也就是说，在收发数据前，必须和对方建立可靠的连接。一个TCP连接必须要经过三次“对话”才能建立起来，其中的过程非常复杂，只简单的描述下这三次对话的简单过程：主机A向主机B发出连接请求数据包：“我想给你发数据，可以吗？”，这是第一次对话；主机B向主机A发送同意连接和要求同步（同步就是两台主机一个在发送，一个在接收，协调工作）的数据包：“可以，你什么时候发？”，这是第二次对话；主机A再发出一个数据包确认主机B的要求同步：“我现在就发，你接着吧！”，这是第三次对话。三次“对话”的目的是使数据包的发送和接收同步，经过三次“对话”之后，主机A才向主机B正式发送数据。
## 2.什么是UDP协议
UDP（User Data Protocol，用户数据报协议）,UDP是一个非连接的协议，传输数据之前源端和终端不建立连接，当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上。在发送端，UDP传送数据的速度仅仅是受应用程序生成数据的速度、计算机的能力和传输带宽的限制；在接收端，UDP把每个消息段放在队列中，应用程序每次从队列中读一个消息段。

#TCP三次握手与四次挥手
## 1.三次握手
为什么需要三次握手本质上来讲是因为信道不稳定，导致数据传输不稳定。
例如这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用三次握手，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。
（1）第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。
（2）第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack (number )=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。
（3）第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。
如图：
![](/assets/三次握手.png)

## 2.四次挥手
由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。
第一次挥手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；
第二次挥手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求；
第三次挥手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；
第四次挥手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。
如图:
![](/assets/四次挥手.png)
## 为什么建立连接是三次,断开连接是四次
这是因为服务端的LISTEN状态下的SOCKET当收到SYN报文的建连请求后，它可以把ACK和SYN（ACK起应答作用，而SYN起同步作用）放在一个报文里来发送。但关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以未必会马上会关闭SOCKET,也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。

# socket简介
## 1. 网络中进程之间如何通信
要实现网络中进程通信,首先要解决的问题就是如何标识一个进程。
在本地可以通过进程的PID值，来标识这个进程，但是在网络当中是不行的。
在之前的学习中，我们知道可以通过ip地址来定位网络当中的一台计算机，而通过端口可以定位到一台计算机上面的某个进程。
这样利用`ip地址和端口`就能达到标识网络中的一个进程，网络中的进程通过这个标识与其他进程进行数据交互。
## 2.什么是socket
socket（简称 `套接字`）是进程间通信的一种方式，它与其他进程间通信的一个主要不同是:它能实现不同主机间的进程间通信,我们网络上各种各样的服务大多都是基于Socket来完成通信的。
## 3.创建socket
在python中使用socket模块的函数socket就可以创建一个socket对象。
`socket.socket(AddressFamily,type)`
说明:
函数socket.socket创建一个socket,返回该socket的描述符,该函数带有两个参数:
* AddressFamily：可以选择AF_INET(用于internet进程间通信)，或者AF_UNIX(用于一台机器之间的通信)，





















     

