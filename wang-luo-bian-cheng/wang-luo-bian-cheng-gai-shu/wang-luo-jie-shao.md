# 网络通信概述
## 1.什么是网络
说明：网络是一种辅助双方或多方连接在一起的工具
## 2.使用网络的目的
为了联通多方进行通信，即把数据从一方传到另一方。
我们之前学习的程序都是单机的，既不能和其他电脑上的程序通信，所以为了能和其他的电脑之间传递数据，需要使用网络。

## 3.传输模型
TCP/IP四层模型
数据链路层：时候也被称作数据链路层或网络接口层，通常包括操作系统中的设备驱动程序和计算机中对应的网络接口卡。它们一起处理与电缆（或其他任何传输媒介）的物理接口细节。
网络层：网络层，有时也称作互联网层，处理分组在网络中的活动。在TCP/IP协议族中，网络层协议包括IP协议（网际协议），ICMP协议（internet互联网控制报文协议），以及IGMP协议（internet组管理协议）。
传输层：传输层主要为两台主机上的应用程序提供端到端的通信。在TCP/IP协议族中，有两个互不相同的传输协议：TCP（传输控制协议）和UDP（用户数据报协议）。





# TCP/IP简介
## 1.什么是协议
为了使数据在网络上从源到达目的，网络通信的参与方必须遵循相同的规则，这套规则称为协议。
## 2.TCP/IP协议（族）
为了把全世界的计算机连接到一起,规定了一套全球通用的协议，也就是互联网协议族。
因为互联网协议包含了上百种协议，但其中最重要的两个是TCP和IP协议，所以互联网协议一般简称为TCP/IP协议。

# 端口
## 1.什么是端口
如果把一个进程比喻为一个房子，那端口就是这个房间的大门，是出入房间的必经之路。
![](/assets/端口.png)

如果一个进程要收发数据,那么就需要有这样的端口.
在linux系统当中，端口可以有65536(2的16次方)个之多。操作系统为了统一管理，所以进行了编号,这就是端口号。
## 2.知名端口号
知名端口就是众所周知的端口号范围从0到1023
比如:80端口 HTTP服务，22 SSH 21 FTP

## 3.动态端口
动态端口的范围从1024到65535
之所以叫动态端口,是因为他一般不固定分配某种服务,而是动态分配的。
动态分配是指当一个系统进程或应用程序经常需要网络通信时，向主机申请一个端口，主机从可用端口号中分配一个供他使用。

# IP地址
## 1.ip地址的作用
用来在网络中标记一台电脑的数字，比如192.168.1.1，在本地局域网上是唯一的。
# TCP和UDP协议
## 1.什么是TCP协议
TCP（Transmission Control Protocol，传输控制协议）是面向连接的协议，也就是说，在收发数据前，必须和对方建立可靠的连接。一个TCP连接必须要经过三次“对话”才能建立起来，其中的过程非常复杂，只简单的描述下这三次对话的简单过程：主机A向主机B发出连接请求数据包：“我想给你发数据，可以吗？”，这是第一次对话；主机B向主机A发送同意连接和要求同步（同步就是两台主机一个在发送，一个在接收，协调工作）的数据包：“可以，你什么时候发？”，这是第二次对话；主机A再发出一个数据包确认主机B的要求同步：“我现在就发，你接着吧！”，这是第三次对话。三次“对话”的目的是使数据包的发送和接收同步，经过三次“对话”之后，主机A才向主机B正式发送数据。
## 2.什么是UDP协议
UDP（User Data Protocol，用户数据报协议）,UDP是一个非连接的协议，传输数据之前源端和终端不建立连接，当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上。在发送端，UDP传送数据的速度仅仅是受应用程序生成数据的速度、计算机的能力和传输带宽的限制；在接收端，UDP把每个消息段放在队列中，应用程序每次从队列中读一个消息段。

#TCP三次握手与四次挥手
## 1.三次握手
为什么需要三次握手本质上来讲是因为信道不稳定，导致数据传输不稳定。
例如这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用三次握手，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。
（1）第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。
（2）第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack (number )=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。
（3）第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。
如图：
![](/assets/三次握手.png)

## 2.四次挥手
由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。
第一次挥手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；
第二次挥手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求；
第三次挥手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；
第四次挥手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。
如图:
![](/assets/四次挥手.png)
## 为什么建立连接是三次,断开连接是四次
这是因为服务端的LISTEN状态下的SOCKET当收到SYN报文的建连请求后，它可以把ACK和SYN（ACK起应答作用，而SYN起同步作用）放在一个报文里来发送。但关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以未必会马上会关闭SOCKET,也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。

# socket简介
## 1. 网络中进程之间如何通信
要实现网络中进程通信,首先要解决的问题就是如何标识一个进程。
在本地可以通过进程的PID值，来标识这个进程，但是在网络当中是不行的。
在之前的学习中，我们知道可以通过ip地址来定位网络当中的一台计算机，而通过端口可以定位到一台计算机上面的某个进程。
这样利用`ip地址和端口`就能达到标识网络中的一个进程，网络中的进程通过这个标识与其他进程进行数据交互。
## 2.什么是socket
socket（简称 `套接字`）是进程间通信的一种方式，它与其他进程间通信的一个主要不同是:它能实现不同主机间的进程间通信,我们网络上各种各样的服务大多都是基于Socket来完成通信的。
## 3.创建socket
在python中使用socket模块的函数socket就可以创建一个socket对象。
`socket.socket(AddressFamily,type)`
说明:
函数socket.socket创建一个socket,返回该socket的描述符,该函数带有两个参数:
* AddressFamily：可以选择AF_INET(用于internet进程间通信)，或者AF_UNIX(用于一台机器之间的通信)，一般常用的都是AF_INET.
* Type:套接字类型,可以是SOCK._STREAM(流式套接字)主要用于TCP协议，或者SOCK_DGRAM(数据报套接字)主要同于UDP协议。

### 创建一个TCP socket
```
import socket
s = socket.socket(family=socket.AF_INET,type=socket.SOCK_STREAM)
print(s)
```
### 创建一个UDP socket
```
import socket
s = socket.socket(family=socket.AF_INET,type=socket.SOCK_DGRAM)
print(s)
```

# UDP 网络程序
创建一个UDP客户端程序,最为简单,具体步骤如下：
1.创建UDP套接字
2.发送/接受数据
3.关闭套接字
![](/assets/UDP程序.png)

代码如下:

UDP服务端程序
```
# 1.导入socket模块
import socket
# 2.创建socket对象
sock = socket.socket(type=socket.SOCK_DGRAM)
# 3.绑定ip和端口
sock.bind(('127.0.0.1', 8080))
# 4.接收请求,返回数据和地址
data,addr = sock.recvfrom(1024)
# 5.打印请求
print(data.decode())
# 6.关闭套接字
sock.close()
```
UDP客户端程序
```
import socket
# 1.创建套接字
s = socket.socket(family=socket.AF_INET,type=socket.SOCK_DGRAM)
# 2.准备接受方的地址
sendAddr = ('127.0.0.1',8080)
# 3.输入要发送的数据
send_data = input('请输入要发送的数据:')
# 4.发送数据到指定电脑
s.sendto(send_data.encode(),sendAddr)
# 5.关闭套接字
s.close()
```

# socket对象常用方法
```
s.bind()	绑定地址（host,port）到套接字， 在AF_INET下,以元组（host,port）的形式表示地址。
s.listen()	开始TCP监听。backlog指定在拒绝连接之前，操作系统可以挂起的最大连接数量。该值至少为1，大部分应用程序设为5就可以了。
s.accept()	被动接受TCP客户端连接,(阻塞式)等待连接的到来
s.connect()	主动初始化TCP服务器连接。一般address的格式为元组（hostname,port），如果连接出错，返回socket.error错误。
s.connect_ex()	connect()函数的扩展版本,出错时返回出错码,而不是抛出异常
s.recv()	接收TCP数据，数据以字符串形式返回，bufsize指定要接收的最大数据量。flag提供有关消息的其他信息，通常可以忽略。
s.send()	发送TCP数据，将string中的数据发送到连接的套接字。返回值是要发送的字节数量，该数量可能小于string的字节大小。
s.sendall()	完整发送TCP数据，完整发送TCP数据。将string中的数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回None，失败则抛出异常。
s.recvfrom()	接收UDP数据，与recv()类似，但返回值是（data,address）。其中data是包含接收数据的字符串，address是发送数据的套接字地址。
s.sendto()	发送UDP数据，将数据发送到套接字，address是形式为（ipaddr，port）的元组，指定远程地址。返回值是发送的字节数。
s.close()	关闭套接字
s.getpeername()	返回连接套接字的远程地址。返回值通常是元组（ipaddr,port）。
s.getsockname()	返回套接字自己的地址。通常是一个元组(ipaddr,port)
s.setsockopt(level,optname,value)	设置给定套接字选项的值。
s.getsockopt(level,optname[.buflen])	返回套接字选项的值。
s.settimeout(timeout)	设置套接字操作的超时期，timeout是一个浮点数，单位是秒。值为None表示没有超时期。一般，超时期应该在刚创建套接字时设置，因为它们可能用于连接的操作（如connect()）
s.gettimeout()	返回当前超时期的值，单位是秒，如果没有设置超时期，则返回None。
s.fileno()	返回套接字的文件描述符。
s.setblocking(flag)	如果flag为0，则将套接字设为非阻塞模式，否则将套接字设为阻塞模式（默认值）。非阻塞模式下，如果调用recv()没有发现任何数据，或send()调用无法立即发送数据，那么将引起socket.error异常。
s.makefile()	创建一个与该套接字相关连的文件
```

TCP编程的服务器端一般步骤是： 
　　1、创建一个socket，用函数socket()； 
　　2、设置socket属性，用函数setsockopt(); * 可选 
　　3、绑定IP地址、端口等信息到socket上，用函数bind(); 
　　4、开启监听，用函数listen()； 
　　5、接收客户端上来的连接，用函数accept()； 
　　6、收发数据，用函数send()和recv()，或者read()和write(); 
　　7、关闭网络连接； 
　　8、关闭监听； 

TCP编程的客户端一般步骤是： 
　　1、创建一个socket，用函数socket()； 
　　2、设置socket属性，用函数setsockopt();* 可选 
　　3、绑定IP地址、端口等信息到socket上，用函数bind();* 可选 
　　4、设置要连接的对方的IP地址和端口等属性； 
　　5、连接服务器，用函数connect()； 
　　6、收发数据，用函数send()和recv()，或者read()和write(); 
　　7、关闭网络连接；

















     

