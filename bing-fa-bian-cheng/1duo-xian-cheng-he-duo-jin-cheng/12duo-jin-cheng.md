# 进程
进程，就是这种“程序切换”的第一种方式。

## 定义
进程，是执行中的计算机程序。也就是说，每个代码在执行的时候，首先本身即是一个进程。

一个进程具有：就绪，运行，中断，僵死，结束等状态（不同操作系统不一样）。
## 使用
用户编写代码(代码本身是以进程运行的)
启动程序，进入进程“就绪”状态
操作系统调度资源，做“程序切换”，使得进程进入“运行”状态
结束/中断
程序执行完，则进入“结束”状态
程序未执行完，但操作系统达到“程序切换”的要求，进入“中断”状态，等待下次被调度后执行

## 特性
* 每个程序，本身首先是一个进程
* 运行中每个进程都拥有自己的地址空间、内存、数据栈及其它资源。
* 操作系统本身自动管理着所有的进程(不需要用户代码干涉)，并为这些进程合理分配可以执行时间。
* 进程可以通过派生新的进程来执行其它任务，不过每个进程还是都拥有自己的内存和数据栈等。
* 进程间可以通讯(发消息和数据)，采用 进程间通信(IPC) 方式。
* 多个进程可以在不同的 CPU 上运行，互不干扰
* 同一个CPU上，可以运行多个进程，由操作系统来自动分配时间片
* 由于进程间资源不能共享，需要进程间通信，来发送数据，接受消息等

多进程，也称为“并行”。

# Python 中的进程
在 Python 中，通过 Python 解释器执行的任何代码，首先本身都是一个进程，比如：
``` -$ python test.py ```

Python 解释器会自动启动一个进程，并加载 test.py 中的代码执行。
我们这里研究的进程是：如何在这样的过程中，创建另一个附加进程，或者说如何创建“子进程”。也就是想办法“手动”创建一个进程，而不是自动生成。
只有能创建“子进程”了，我们才能手动编些进程来执行额外的代码，而不是Python 自动创建，自动执行，有助于我们合理和灵活的利用多 CPU 的情形。

## 创建子进程

#### fork()
在Unix/Linux操作系统提供了一个fork()函数，它非常特殊，调用一次，返回两次，因为操作系统将当前的进程（父进程）复制了一份（子进程），然后分别在父进程和子进程内返回。windows不支持fork方法。
```
import os
pid = os.fork()
if pid == 0:
    print('子进程')
else:
    print('父进程')
    ```
说明:
* 程序执行到`os.fork()`的时，操作系统会创建一个新的进程(子进程)，然后复制父进程的所有信息到子进程。
* `os.fork()`的返回值有两个，子进程返回0，父进程返回子进程的id，这样做的理由是，一个父进程可以fork()出很多子进程，所以，父进程要记下每个子进程的ID，而子进程只需要调用getppid()就可以拿到父进程的ID。

#### getpid() getppid()

```
import os

pid = os.fork()
if pid == 0:
    print('我是子进程{},我的父进程是{}'.format(os.getpid(),os.getppid()))
else:
    print('我是父进程{},我的子进程是{}'.format(os.getpid(),pid))
```

* 思考： 当出现多次fork时，进程的变化 

#### multiprocessing

由于Python是跨平台的，自然也应该提供一个跨平台的多进程支持。multiprocessing模块就是跨平台版本的多进程模块。
multiprocessing模块提供了一个Process类来代表一个进程对象，下面的例子演示了启动一个子进程并等待其结束：
```
from multiprocessing import Process
import os

# 子进程要执行的代码
def run_proc(name):
    print('子进程运行中，name= %s ,pid=%d...' % (name, os.getpid()))

if __name__=='__main__':
    print('父进程 %d.' % os.getpid())
    p = Process(target=run_proc, args=('test',))
    print('子进程将要执行')
    p.start()
    p.join()
    print('子进程已结束')
```
说明:
* 创建子进程时，只需要传入一个执行函数和函数的参数，创建一个Process实例，用start()方法启动，这样创建进程比fork()还要简单。
* join()方法可以等待子进程结束后再继续往下运行，通常用于进程间的同步。

Process语法结构如下：

Process([group [, target [, name [, args [, kwargs]]]]])

target：表示这个进程实例所调用对象；

args：表示调用对象的位置参数元组；

kwargs：表示调用对象的关键字参数字典；

name：为当前进程实例的别名；

group：大多数情况下用不到；

